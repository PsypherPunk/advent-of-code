package main

import (
	"bufio"
	_ "embed"
	"fmt"
	"strconv"
	"strings"
)

//go:embed input.txt
var input string

func mixSecret(secret, value int) int {
	return secret ^ value
}

func pruneSecret(secret int) int {
	return secret % 16777216
}

func evolveSecret(secret int) int {
	result := secret * 64
	secret = mixSecret(secret, result)
	secret = pruneSecret(secret)

	result = secret / 32
	secret = mixSecret(secret, result)
	secret = pruneSecret(secret)

	result = secret * 2048
	secret = mixSecret(secret, result)
	secret = pruneSecret(secret)

	return secret
}

func PartOne(input string) int {
	scanner := bufio.NewScanner(strings.NewReader(input))

	secretNumbers := []int{}
	for scanner.Scan() {
		line := scanner.Text()
		secretNumber, err := strconv.Atoi(line)
		if err != nil {
			fmt.Println("invalid line:", line)
		}
		secretNumbers = append(secretNumbers, secretNumber)
	}

	sumSecretNumbers := 0
	for _, secretNumber := range secretNumbers {
		secret := secretNumber
		for i := 0; i < 2000; i++ {
			secret = evolveSecret(secret)
		}
		sumSecretNumbers += secret
	}

	return sumSecretNumbers
}

func PartTwo(input string) int {
	scanner := bufio.NewScanner(strings.NewReader(input))

	secretNumbers := []int{}
	for scanner.Scan() {
		line := scanner.Text()
		secretNumber, err := strconv.Atoi(line)
		if err != nil {
			fmt.Println("invalid line:", line)
		}
		secretNumbers = append(secretNumbers, secretNumber)
	}

	sequences := make(map[[4]int]int)

	for _, secretNumber := range secretNumbers {
		onesDigit := secretNumber % 10
		changes := make([][2]int, 0, 2000)

		for i := 0; i < 2000; i++ {
			secretNumber = evolveSecret(secretNumber)
			evolvedOnesDigit := secretNumber % 10
			changes = append(changes, [2]int{evolvedOnesDigit - onesDigit, evolvedOnesDigit})
			onesDigit = evolvedOnesDigit
		}

		seen := make(map[[4]int]bool)

		for i := 0; i < len(changes)-4; i++ {
			var consecutiveChanges [4]int
			for j := 0; j < 4; j++ {
				consecutiveChanges[j] = changes[i+j][0]
			}

			bananas := changes[i+3][1]

			if !seen[consecutiveChanges] {
				seen[consecutiveChanges] = true
				sequences[consecutiveChanges] += bananas
			}
		}
	}

	mostBananas := 0
	for _, bananas := range sequences {
		if bananas > mostBananas {
			mostBananas = bananas
		}
	}

	return mostBananas
}

func main() {
	fmt.Println("What is the sum of the 2000th secret number generated by each buyer?", PartOne(input))

	fmt.Println("What is the most bananas you can get?", PartTwo(input))
}
